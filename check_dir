#!perl

# RCS information (required by Perl::Critic)
# enable substitution with:
#   $ svn propset svn:keywords "Id Revision HeadURL Source Date"
#
#   $Id$
#   $Revision$
#   $HeadURL$
#   $Date$

use strict;
use warnings;

use 5.008;

use Getopt::Long;
use Carp;
use English qw(-no_match_vars);

use Nagios::Plugin;
use Nagios::Plugin::Threshold;
use File::stat;
use Pod::Usage qw(pod2usage);

use version; our $VERSION = '2.1.2';

# IMPORTANT: Nagios plugins could be executed using embedded perl in this case
#            the main routine would be executed as a subroutine and all the
#            declared subroutines would therefore be inner subroutines
#            This will cause all the global lexical variables not to stay shared
#            in the subroutines!
#
# All variables are therefore declared as package variables...
#
use vars qw(
  $critical
  $help
  $n
  $plugin
  $recursive
  $result
  $status
  $info_string
  $threshold
  $verbosity
  $warning
  @dirnames
);

# initialization
$plugin      = Nagios::Plugin->new(
    shortname => 'CHECK_DIR'
);
$verbosity   = 0;
$status      = 0;

##############################################################################
# subroutines

##############################################################################
# Usage     : max($i, $j)
# Purpose   : returns the maximum of two integers
# Returns   : the maximum of two integers
# Arguments : the integers to compare
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub max {

    my ($i, $j) = @_;

    if ($i > $j) {
        return $i;
    }
    else {
        return $j;
    }
    
}

##############################################################################
# Usage     : verbose("some message string", $optional_verbosity_level);
# Purpose   : write a message if the verbosity level is high enough
# Returns   : n/a
# Arguments : message : message string
#             level   : options verbosity level
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub verbose {

    # arguments
    my $message   = shift;
    my $level     = shift;

    if ( !defined $message) {
        $plugin->nagios_exit(UNKNOWN, q{Internal error: not enough parameters for 'verbose'});
    }
    
    if ( !defined $level ) {
        $level = 0;
    }

    if ( $level < $verbosity ) {
        print $message;
    }

    return;

}

##############################################################################
# Usage     : check_dir("directory_name")
# Purpose   : checks the number of files in the given directory
# Returns   : n/a
# Arguments : dirname: the name of the directory to check
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub check_dir {

    my $dirname = shift;
    my $info;
    my @files;
    my $DIR;

    ###############################
    # check if the directory exists

    if ( !-d $dirname ) {
        $plugin->nagios_exit( UNKNOWN, "Folder $dirname does not exist." );
    }

    ####################################
    # check if the directory is readable

    $info = stat $dirname
      or $plugin->nagios_exit( UNKNOWN, "Can't read stat for $dirname: $OS_ERROR" );

    if ( !( ( $info->mode & oct 5 ) || ( $info->uid == $REAL_USER_ID ) ) ) {
        verbose "skipping $dirname: Permission denied\n";
        return;
    }

    #######################
    # get directory listing

    verbose "Opening $dirname\n", 1;
    
    opendir $DIR, $dirname or
        $plugin->nagios_exit( UNKNOWN, "Can't open $dirname: $OS_ERROR");

    @files = readdir $DIR;
    @files = sort grep { !/^\./mx } @files ;

    closedir $DIR
        or $plugin->nagios_exit( UNKNOWN, "Error closing $dirname: $OS_ERROR" );

    $n = @files;

    #################
    # Additional info
    verbose "Directory '$dirname' has $n files\n";

    #################
    # Output (status)

    $plugin->add_perfdata(
        label     => $dirname,
        value     => $n,
        uom       => q{},
        threshold => $threshold,
    );

    if ( defined $info_string ) {
        $info_string = "$info_string, $dirname=$n";
    }
    else {
        $info_string = "$dirname=$n";
    }

    $status = max($status, $threshold->get_status($n));

    ###########
    # Recursive
    if ($recursive) {
        foreach my $file (@files) {
            if ( -d "$dirname/$file" ) {
                check_dir("$dirname/$file");
            }
        }
    }

    return;
}

##############################################################################
# main

########################
# Command line arguments

$result = GetOptions(
    'dir=s'        => \@dirnames,
    'critical|c=s' => \$critical,
    'warning|w=s'  => \$warning,
    'help|h|?'     => \$help,
    'recursive|r'  => \$recursive,
    'verbose|v+'   => \$verbosity,
    'version|V'    => sub { print "check_dir version $VERSION\n"; exit 3; }
);

#############################
# Sanity checks: command line

if ( !$result ) {
    pod2usage(
        -exitval => UNKNOWN,
    );
}

if ( $help )          { pod2usage(); }

if (! $critical ) {
    pod2usage(
        -exitval => UNKNOWN,
        -message => 'missing --critical'
    );
}
my $critical_range = Nagios::Plugin::Range->parse_range_string( $critical );
if (! $critical_range->is_set() ) {
    pod2usage(
        -exitval => UNKNOWN,
        -message => 'Could not parse "critical"'
    );
}
if (! $warning ) {
    pod2usage(
        -exitval => UNKNOWN,
        -message => 'missing --warning'
    );
}
my $warning_range  = Nagios::Plugin::Range->parse_range_string( $warning );
if (! $critical_range->is_set() ) {
    pod2usage(
        -exitval => UNKNOWN,
        -message => 'Could not parse "warning"'
    );
}
    
$threshold = Nagios::Plugin::Threshold->set_thresholds(
    warning  => $warning_range,
    critical => $critical_range,
);

##########################
# Sanity checks: directory

foreach my $dirname (@dirnames) {
    if (! -d $dirname) {
        $plugin->nagios_exit(UNKNOWN, "Error: $dirname is not a directory");
    }
    if (! -r $dirname) {
        $plugin->nagios_exit(UNKNOWN, "Error: $dirname is not readable");
    }
    if (! -x $dirname) {
        $plugin->nagios_exit(UNKNOWN, "Error: $dirname is not executable");
    }
}

#############
# Process dir

foreach my $dirname (@dirnames) {
    check_dir($dirname);
}

$plugin->nagios_exit( $status, $info_string );

1;
